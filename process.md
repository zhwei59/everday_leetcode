## 能否修改一次数组成为非递减序列
[-1,4,2,3,7,8,9]
对于任何i，都有A[i]<=A[i+1]
很巧妙，至多允许 一次 A[i]>a[i+1]
如果 遍历完，只有一个p，
要么减小p,要么增大p+1
那么考虑两种情况，p+1比p-1大的，那么允许调整p。p比p+2小的，调整p+1
## 右旋数组的k个元素
[1,2,3,4,5,6,7]=>[5,6,7,1,2,3,4]
split=n-k-1 # 十分注意-1
reverse all
reverse left
reverse right
## 输出第三大的数
f,s,t保存下来
#1 Two Sum

#1 两数之和
	求一个数组内两个数的和等于target
解法一：暴力搜索
[0,1]查剩下的元素是否满足sum=target
复杂度为:O(n^2)
解法二：哈希表
//重复无法处理。
哎呀，真是蠢。
解法三：先排序

# 1.Two Sum
最简单的，没有难度
# 2.Add Two Numbers
。。。。
将短的那条处理成后面都是0.
None即不做任何东西。
关于c的处理，真是编程技巧。。。
# 3.最长不重复子串长度
垃圾垃圾垃圾垃圾垃圾、
你就是个垃圾
# 4.两个数组 的 中位数
找准位置
# 5.寻找回文字符串
暴力回溯！
注意回退
# 6.倒序整数
2147483647
如何取每个位置上的数呢？
# 7.倒序整数
# 8.字符转数字
	输入: str=" +123" 输出: 123
	输入: str="-123fe2" 输出: -123
正则表达式
或者手撸
# 9 回文数字
额外的空间是指 数组。
直白的想法是把数字翻转过来
高级点的编程
分别取头尾来判断是否相等。
%div
//10
# 10
# 11 两板之间最大的面积
双向遍历，如果左<右，尝试增大左 ，否则增大右边
# 12 罗马转数字
# 13 数字转罗马
# 14 最长公共子串
# 15 三数之和
只能想到暴力遍历，以及练练不重复的写法。
# 16 三数之和最接近 target的和
分别去处理。
# 17 诺基亚键盘
练一下递归
# 18 求4数之和等于target
# 19 去掉链表中的倒数第n个数
嗯嗯，明白了一点，head=head.next是指针的移动，head.next=head.next.next那么就是结构的改变啦。
#20 判断符号是否合规
append-pop
。。。看来我真是个蠢逼。。。
# 21 合并两个排序链表
真是个蠢逼无疑了。。。
# 22 生成所有合法的括号组合
我们来看一下怎么是不合法的，就是右括号数大于左括号数。
它是怎么把每种情况都遍历到的？
这种写法不会导致每次都只加左括号吗？
# 23 合并多个列表
priorityQueue
#24 交换两个节点
1-2-3-4 =》2-1-4-3
给跪了。。。。
想法太巧了，我其实根本不变链表，只改数值！！！
#25 交换多个节点
跟上面差不多
# 26 去重数组中重复元素
刁钻，草
# 27 数组去除指定元素 返回不重复数组
就是这么简单
# 28 indexof(str)的功能
实际上难点是get_next，确实是这个啊啊啊啊，当p[i]!=p[j]时，要回退！！叠词最恐怖 aaa =》[0,1,1]
# 29 实现除法
先涨后降。。。
# 30 字典
# 31 不会
# 32 最长合法括号
确实是个蠢逼。。。
动态规划也不会。。。
# 34 查找有序数组中，目标值的位置起始位置和结束位置。
确实要想清楚啊，当相等的时候，要先移动右边，你移动左边的话肯定就走远了，
后面反而是移动左边，移动右边的话就走远了。
# 35 找出插入位置
又是二分查找题
分几种情况讨论：等于目标时，或者mid==0 或 mid-1小，mid大于 返回mid
还有一种情况是，mid==length-1，并且mid要比target小，返回mid+1
# 36 组合数之和等于target
技能:nums,current+v,target,result
对于这种 个数无法确定啊，所以只能 遍历。一个一个地添加，而不是双方向推进。
博大精深呐
# 37 
# 38 计数表达
额。。
#39 组合数之和等于target
标准的回溯法
拆掉思维里的墙
程序设计的本质-----------抽象和自动化-----------
# 40


#2 链表加和
	求两个链表的加法，涉及进位
解法一：
同时遍历l1和l2，大于10进1位
依次遍历剩下的l1和l2
复杂度：没有改善空间。
# 3 最大不重复子串
	求字符串不重复字符子串
解法：
哈希表存放字符，用一个量记录边界，边界不停移动，得到最大长度
点：记录边界，长度计算。
复杂度：没有改善空间，哈希表占用空间其实不大。
# 4 两个排序数组的中位数
	求两个数组合并后的中位数
解法一：
暴力遍历
点：中位数的位置，都要取大的，整除要加一，不整除去后面点。
# 5 最长回文子串
	求字符串的最长回文子串
解法一：
暴力解
遍历所有子串。n^3
解法二：
对称解法
按照对称性，可以排除很多子串，复杂度降为n^2
解法三：Manacher算法
# 7给定一个整数，翻转它
	翻转整数
neg_limit= -0x80000000
pos_limit= 0x7fffffff
解法：
res=R*res+x%R
x/=R
哎
# 8 字符串转整数
解法一：
合法性
符号 等的判断
解法二：
正则表达
re.match("re",str)
# 9 回文数字
	判断一个数字是否是回文数字
解法一：
翻转数字判断，是否原来数字相等
点：个位为0翻转后，原数要除以10
# 10 正则匹配
	实现*和.的模糊匹配
无论哪种解法都需要first_match
解法1：
自上而下的递归 效率低
first_match
如果 parttern[1]是* 返回text和parttern[2:]的结果 或者 first_match和text[1:]与parttern的递归。

否则返回 first_match 和text[1:] parttern[1:]的真假

解法2：
自下而上的动态规划  用二维数组保存历史结果。
# 11 装水最多的容器
# 12 数字转罗马
# 13 罗马转数字
# 14 最长公共前缀
	给定一些串，找到最长公共前缀

# 15 三数之和
	在数组中找三数之和等于target的所有组合
解法：
sort+判断 关键是如何去重呢
编程能力真是弱

# 16 三数之和
	在数组中找出最接近target 的三个数之和
解法：
还是暴力
sort 暴力遍历之，判断最小的abs(target-val)就行了
# 17 手机键盘的字母组合
	输入数字，诺记能打出的所有字母组合
解法一：
额。。。。循环，每次处理两个值，前面处理好的值作为输入，拼上后面，一直到digits。。。
解法二：
递归 。。。if(s.size==digits.size) push...
# 18 4数之和
解法：
排序
固定一维后，转化成3个数的和。不算难，细心就行。
# 19 删除链表倒数第k个数
下巴掉了。步长
first和second保证了距离。。。巧妙
# 20 判断一个括号是否合法
	()
用了个栈
# 21 合并两个有序链表
	两个有序链表合并
新建Node呢还是不呢？是个问题。。。
不一定要遍历完。。。
# 23 合并多个有序序列
解法一：暴力重构
	全部重构
解法二：最小堆
	重构head
# 24 交换链表节点
	1->2->3->4 2->1->4->3
# 26 去除有序数组的重复元素
	水题
# 27 去除数组中所有等于某个数的元素
	水提
# 28 字符串查找
	匹配子串
解法一：暴力搜索O(m*n)
解法二：kmp O(m+n)
next数组。就是如果发生不匹配了，但是也许是重头开始的呢，next数组就是找到pattern中，如果发生不匹配这件事，多少东西可以作为开通呢。
            if string[i]==match[j]:
                i+=1
                j+=1
                if j==m:
                    return i-j
            elif j>0:
                j=n_arr[j-1]
            else :
                i+=1
# 29 实现除法
不知道移位是为了啥。。
neg = dividend > 0 and divisor < 0 or dividend < 0 and divisor > 0
# 30 所有单词连接的子串
	给定一个无重复单词的字典D，和一个长字符串S。找出S中的子串，该子串恰好是D中所有单词连接而成。
外循环肯定是6次，不然就重复了
如果 当前字典都没有重复的，并且长度相等，那么加入到res中
# 45 青蛙跳2
	判断最少几步可以走完
双滑动，如果longest落后了，换reach，counter++，没落后就搞reach就行了。
# 46 全排列
	给定数组的全排列
复利你懂吗？
输入的是剔除掉自己的你懂吗 哈哈，好菜啊
# 47 有重复数字的全排列
	和上面的全排列差不多，只是数组的元素是有重复的
偷懒 数组排个序，重复的跳过就是了
# 48 矩阵翻转
	1 2 3		7 8 1
	8 9 4  -》	6 9 2
	7 6 5 		5 4 3
数组元素的交换
# 49 变位词归类
	["eat", "tea", "tan", "ate", "nat", "bat"]->[['nat', 'tan'], ['bat'], ['ate', 'eat', 'tea']]

排序+hash表
# 50 实现幂
	x = 2, n = -1=》0.5
	x = 2.1, n = 2 =》4.41
为啥多此一举定义i呢？
# 51 n皇后
	棋子落下的地方，行，列，对角线，反对角线都只能只有一个棋子！！！

本质还是暴力搜索
	对角线的表示：dig[row+col]
	反对角线的表示：
# 56 螺旋输出矩阵
矩阵不一定对称
套路就是 四个方向 进攻！！！最后来讨论特殊情况~
# 57 合并区间
真的，看他的解决方式就是种享受，这货思路太广了，解决问题能力贼牛
# 58 加入新区间并合并

# 59 输入n,输出螺旋方阵
result=[[0 for __in range(n)] for _ in range(n)]
[填数 for _ in range(x) ]
框填数for下inrange
# 60 找出n!中第k小的数
观察，可以看到，每确定一位，可能性就减少到(n-1)!
所以我们可以逐步确定每一位。。。
# 61 旋转链表
所谓的旋转就是链表某处断开，收尾相连，k是从左边数的第k个元素，所以如果k>length，转一圈后，还是从右边数k个。
先把头尾连起来，同时计算一下链表的长度
1->2->3
2->3->1
length=3 k=5
shift=3-5%3 很正确啊，从尾巴往前数k，然后next返回来，next再断掉。

# 62 到达点(m,n)的方式
Cm+n n
(m+n)!/(m!*n!) 呸
或者更常见的动态规划。
[[1,1][1,1]]
那么要到达 j,i点有两种方式，从上边下来：j,i-1或者从左边过来，j-1,i

# 63 机器人到达m，n的方式
比起上面的问题，多了一个障碍物的套路。
同时要主要top行，和left行的问题，也是上面的问题没有注意到的。
思维确实很重要。。。思路清晰的话，肯定没有问题。
# 64 到达(m,n)经过的数字最小
思路肯定类似，但是要转化问题
把存储 左边和上边的走法变成 最小数字和。
为了节省空间，他还想出了压缩dp为一维，这编程能力确实不错。
# 65 数组加1
# 66 二进制字符串加1
# 67 -70 都是easy
# 71 简化Unix下的路径
为什么我就想到这里去呢？抽象，简化逻辑呢？
# 72 最小编辑距离
这也能动态规划？
# 73 矩阵元素置为0
	当矩阵的行或者列上有0的元素，请把该元素的行和列都设为0
# 77 输入 n,k
	 n = 4 and k = 2
	 [
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],]
虽然很华丽，但是很难掌握啊。。
# 78 子集
求数组的所有子集：
这个递归我服。
# 84 柱状图最大面积
	如何用栈构造升序列~！
巧妙地用栈构造递升序列！！！
由于0的存在，双指针并不好用。
# 88 合并数组
考虑的大的，用倒序！！！
# 97 判断第三个字符串是否由 s1,s2的字符交替生成。
递推式思想。假设s2为空。
dp[i]= s1[i]=s3[i]
逐渐增加j的长度
如果s3[]
# 98 判断二叉树的合法性
二叉树的中序遍历是个递增序列

# 100 判断树是否相同
递归
## 动态规划思想
面对求解最优或者统计的问题时，要反应起用动态规划，将大任务化解成若干个小问题。

举个最简单的例子
建设a->z，中间要经过若干个站，如何选择一条最短的路径?
这个问题，第一层，是贪心
a->(i,j)->(m,n)->(z)，你发现第一步你可以到i或j地，第二步你可以选择m或者n,诶，如果把第一步最优结果和第二步的最优结果，结合起来，是不是最优的结果。不错，这确实最贪心的结果，如果第一步和第二步之间没有任何关系，贪心策略是正解。

然而现实是，如果你第一步选了i，可能i无法到达m。那只好把所有路径都枚举出来，一一比较。这便是第二个极端，暴力穷举。

既然前面的两种的方式都只能满足一些需求，那么结果前面两种思路，我们把步骤分解，把到每个点的最优状态记录下来，然后用贪心的算法找出整体最优的结果！从而将复杂度从x^(a+b+c)降低到x^a+x^b+x^c

然而，动态规划核心却是BFS！！a BFS到 i,保留下最优，然后后面的判断直接从I开始BFS，直到BFS到z。

入门：背包问题。

呜哈哈~！！
学习动态规划有什么捷径？
答：我们将动态规划的常见类型分为如下几种：
* 矩阵型
* 序列型
* 双序列型
* 划分型
* 区间型
* 背包型
* 状态压缩型
* 树型

问1
动态规划是个什么鸟蛋？
答：动态规划是一种通过“大而化小”的思路解决问题的算法。区别于一些固定形式的算法，如二分法，宽度优先搜索法，动态规划没有实际的步骤来规定第一步做什么第二步做什么。所以更加确切的说，动态规划是一种解决问题的思想。这种思想的本质是，一个规模比较大的问题（假如用2-3个参数可以表示），是通过规模比较小的若干问题的结果来得到的（通过取最大，取最小，或者加起来之类的运算）所以我们经常看到的动态规划的核心——状态转移方程都长成这样：
* f[i][j] = f[i - 1][j] + f[i][j - 1]
* f[i] = max{f[j] if j < i and …} + 1
* f[i][j] = f[0][j - 1] && judge(1,i) || f[1][j - 1] && judge(2,i) || …

问2
动态规划面试考得多么？
答：多。并且越来越多。随着CS从业与求职者的增加，并伴随大家都是“有备而来”的情况下，一般简单的反转链表之类的题目已经无法再在面试中坚挺了。因此在求职者人数与招聘名额的比例较大的情况下，公司会倾向于出更难的面试问题。而动态规划就是一种比较具有难度，又比较“好出”的面试问题。相比其他的算法与数据结构知识来说，贪心法分治法太难出题了，搜索算法往往需要耗费求职者过长的程序编写时间一般也不倾向于出，二叉树链表等问题题目并没有那么多，而且求职者也都会着重准备这一块。因此动态规划这一类的问题，便越来越多的出现在了面试中。

问3
动态规划快在哪儿？
答：动态规划一般来说是“高效”的代名词，因为其解决的问题一般退而求其次的算法只有搜索了。以“数字三角形”一题为例子（Triangle ），在“三角矩阵”中找一条从上到下的路径，使得权值之和最小。如果使用暴力搜索的算法，那么需求穷举出2^(n-1)条路径（n为三角形高度），而使用动态规划的话，则时间复杂度降低到了n^2，完成了质的飞跃。那么究竟为什么这么快呢？原因在于动态规划算法去掉了“无用和重复的运算”。在搜索算法中，假如从A->B有2条路径，一条代价为10，另外一条代价为100，B->终点有1024条路径。当我们选择了代价为10的那条路径走到B时，可以继续往下走完1024条路径到终点，但是在此之后，我们再从代价为100的路径从A走到B时，我们可以发现此时无论如何走，都不可能有刚才从10的路径走过来更好，所以这些计算是“无用”的计算，也可以说是“重复”的计算。这就是动态规划之所以“快”的重要原因。

问4
学习动态规划有什么捷径？
答：我们将动态规划的常见类型分为如下几种：
* 矩阵型
* 序列型
* 双序列型
* 划分型
* 区间型
* 背包型
* 状态压缩型
* 树型
其中，在技术面试中经常出现的是矩阵型，序列型和双序列型。划分型，区间型和背包型偶尔出现。状态压缩和树型基本不会出现（一般在算法竞赛中才会出现）。
每种类型都有着自己的题目特点和状态的表示方法。以矩阵型动态规划为例，一般题目会给你一个矩阵，告诉你有一个小人在上面走动，每次只能向右和向下走，然后问你比如有多少种方案从左上走到右下 (Unique Paths)。这种类型状态表示的特点一般是使用坐标作为状态，如f[i][j]表示走到(i,j)这个位置的时候，一共有多少种方案。状态的转移则是考虑是从哪儿走到(i,j)这个坐标的。而序列型的动态规划，一般是告诉你一个序列；双序列的动态规划一般是告诉你两个字符串或者两个序列。
将所做过的动态规划问题按照这些类别进行归类，分析状态的表示方法和状态转移方程的构造方法在每种类型中的近似之处，会让你更快的学会动态规划。

问5
什么样的问题适合使用动态规划？
答：可以使用动态规划的问题一般都有一些特点可以遵循。如题目的问法一般是三种方式：
1. 求最大值/最小值
2. 求可不可行
3. 求方案总数
如果你碰到一个问题，是问你这三个问题之一的，那么有90%的概率是使用动态规划来求解。
要重点说明的是，如果一个问题让你求出“所有的”方案和结果，则肯定不是使用动态规划。

问6
解决一个动态规划问题的步骤是什么？
答：首先根据“问5”判断是否是动态规划的问题，如果是，则尝试将其按照“问4”进行分类，找到对应的类别和相似的问题。接着从下面的4个要素去逐步剖析解决这道题：
1. 状态是什么
2. 状态转移方程是什么
3. 状态的初始值是什么
4. 问题要求的最后答案是什么
每个步骤分析完成之后，就基本上解决了整道动态规划的问题。

问7
怎样优化动态规划的时间？
答：一般来说，使用动态规划求解的问题，时间上已经比暴力搜索要优化很多了。但是仍然存在着一些可以优化的空间。通常来说，动态规划的时间优化，有如下两种常见的方式：
1. 通过变换状态优化
2. 通过决策单调优化
对于通过变换状态来优化的问题比较难，需要一些经验和灵感。而对于决策单调的优化，则比较简单，但适用范围不广，一般只适用于划分型动态规划当中，通常这个方法可以将复杂度降低一个数量级。

问8
怎样优化动态规划的空间？
答：动态规划的空间优化只有一种方法，就是使用滚动数组进行优化。以一个二维的动态规划为例子。假如状态转移方程如下：f[i][j] = f[i - 1][j] + f[i][j - 1]。我们可以发现，第i层的状态，已经和第i-2层的状态没有关系了，那么这种情况下，用于存储第i-2层的空间就可以被重复利用。方法非常简单，把数组的第一维对2取模就可以了：f[i % 2][j] = f[(i - 1) % 2][j] + f[i % 2][j-1]。这种方法通常可以将空间复杂度降低一个数量级。


## 动态规划训练策略
### 矩阵型

### 序列型
514. 栅栏染色
动态规划，有趣在本质子问题一定要找对~！第i根柱子跟i-1不同，第i根柱子跟i-2不同。因此才得出：
dp[i]=(dp[i-1]+dp[i-2])*(k-1) 然后就简单啦~
397. 最长上升连续子序列
额，动态规划要小心边界。。。尤其是空数组，长度不够这些！~
dp[i]=2 or dp[i]=dp[i-1]+1就看条件咯
398.爬楼梯
发现另一种玩法。。。。但是要注意赋值，其实也就是压缩。。。
if n<=1:
	return n
res=i_1+i_2
i_1,i_2=i_2,res
92.背包问题
好像我ac的算法不是主流算法= =用了一个map来保存历史sum的可能性。

622.青蛙跳
按照顺序给出石头所在的位置，判断青蛙能否到达最后一块石头所在的位置。刚开始时青蛙在第一块石头上，假设青蛙第一次跳只能跳一个单位的长度。

如果青蛙最后一个跳 k 个单位，那么它下一次只能跳 k - 1 ，k 或者 k + 1 个单位。注意青蛙只能向前跳。

原始问题：[0,1,3,5,6,8,12,17]
初始化：不是[0,1]不可以
枚举：
0，1，（0，1，2）{递归}
dp[i]=for i in dp[i-1] +(k-1,k,k+1)
set add
89. k数和 
用target作为动态规划的点，原始问题是[i][j]从i中选j个数的和等于target
所以有dp[i][j][target]=dp[i][j-1][target-A[i]]


### 双序列型
